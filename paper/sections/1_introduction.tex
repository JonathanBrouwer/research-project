\section{Introduction}
Haskell is a strongly typed, purely functional programming language \cite{haskell}. An advantage of this is that it simplifies reasoning about the correctness of algorithms and data structures. Even though this reasoning is simple, Haskell does not provide mechanisms to guarantee this correctness as the code changes, so there is still a risk of making mistakes. In contrast, Agda is a dependently typed programming language and interactive theorem prover \cite{agda}.  Using Agda and the Curry-Howard correspondence \cite{chc}, it is possible to write a formal proof about the code in the language itself, and to use the compiler to verify the correctness of the proof \cite{schwaab, van}. The compiler also verifies that the proof is still valid each time the code changes.

Agda2hs \cite{agda2hs} is a program which identifies a common subset of Agda and Haskell, and provides a tool that automatically translates code from this subset of Agda to Haskell. This makes it possible to write a program in this subset, using the power of Agda to prove properties about it, and then translate the Agda code to readable Haskell code. However, Agda2hs is not completed yet, as it still lacks some Agda features that it cannot compile to Haskell. It is also not yet known how much extra effort it takes to write code in this subset of Agda.

In this paper, the QuadTree library is implemented and verified in the subset of Agda that can be compiled by Agda2hs, to determine:
\begin{enumerate}[label=(\roman*)]
	\itemsep-0.2em 
	\item Can the QuadTree library be implemented in the subset of Agda that can be compiled by Agda2hs? (section 3)
	\item What properties does the QuadTree library guarantee? (section 4.1)
	\item How can the properties that the QuadTree library guarantees be proven? (section 4.2-4.5)
	\item How can the time and effort required to verify the QuadTree library be reduced? (section 6)
\end{enumerate}
